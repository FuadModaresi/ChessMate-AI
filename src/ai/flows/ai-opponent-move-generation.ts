// This file is generated by Firebase Studio.
'use server';
/**
 * @fileOverview This file defines a Genkit flow for generating chess moves by an AI opponent.
 *
 * - aiOpponentMove - A function that takes the current board state and difficulty level and returns a chess move in UCI notation.
 * - AiOpponentMoveInput - The input type for the aiOpponentMove function.
 * - AiOpponentMoveOutput - The return type for the aiOpponentMove function, representing a chess move in UCI notation.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';
import {Chess} from 'chess.js';

const AiOpponentMoveInputSchema = z.object({
  boardState: z.string().describe('The current state of the chess board in FEN notation.'),
  difficulty: z
    .enum(['Beginner', 'Intermediate', 'Advanced'])
    .describe('The difficulty level of the AI opponent.'),
});
export type AiOpponentMoveInput = z.infer<typeof AiOpponentMoveInputSchema>;

const AiOpponentMoveOutputSchema = z.object({
  bestMove: z.string().describe('The best chess move for the current player in UCI notation.'),
  validMoves: z.array(z.string()).describe('A list of all valid moves for the current player in UCI notation.'),
});
export type AiOpponentMoveOutput = z.infer<typeof AiOpponentMoveOutputSchema>;

export async function aiOpponentMove(input: AiOpponentMoveInput): Promise<AiOpponentMoveOutput> {
  return aiOpponentMoveFlow(input);
}

const aiOpponentMovePrompt = ai.definePrompt({
  name: 'aiOpponentMovePrompt',
  input: {schema: AiOpponentMoveInputSchema},
  output: {
    schema: AiOpponentMoveOutputSchema,
  },
  prompt: `You are a chess grandmaster AI, playing against a human opponent.

You are playing as the black pieces.

You are playing at {{difficulty}} difficulty.

The current board state in FEN notation is: "{{{boardState}}}"

First, identify ALL valid moves for black in UCI notation.
Then, from that list, determine the best possible strategic move.

You must provide your response in the requested JSON format. The bestMove field must contain a valid UCI move from the list of valid moves.

If you cannot determine a move for any reason, return an empty string for bestMove and an empty array for validMoves.
`,
});

const aiOpponentMoveFlow = ai.defineFlow(
  {
    name: 'aiOpponentMoveFlow',
    inputSchema: AiOpponentMoveInputSchema,
    outputSchema: AiOpponentMoveOutputSchema,
  },
  async input => {
    try {
      const game = new Chess(input.boardState);
      const validMoves = game.moves({ verbose: false });

      if (validMoves.length === 0) {
        return { bestMove: '', validMoves: [] };
      }
      
      const {output} = await aiOpponentMovePrompt(input);

      if (output) {
        // Ensure the returned bestMove is actually valid
        if (validMoves.includes(output.bestMove)) {
          return output;
        }
      }
      
      // Fallback if AI fails or returns an invalid "best" move
      return { bestMove: validMoves[0], validMoves: validMoves };

    } catch (error) {
      console.error('Error in aiOpponentMoveFlow:', error);
      // In case of a catastrophic error, try to generate moves locally.
      try {
        const game = new Chess(input.boardState);
        const moves = game.moves({verbose: false});
        if (moves.length > 0) {
          return { bestMove: moves[0], validMoves: moves };
        }
      } catch (e) {
        console.error('Error in fallback move generation:', e)
      }

      return { bestMove: '', validMoves: [] };
    }
  }
);
